{
  "api/index.html": {
    "href": "api/index.html",
    "title": "aas-core 3.0RC02 C# API",
    "keywords": "aas-core 3.0RC02 C# API The API of the SDK is split into six different units: Namespace Description AasCore.Aas3_0_RC02 Create the model programmatically AasCore.Aas3_0_RC02.Visitation Iterate over and transform the model AasCore.Aas3_0_RC02.Constants Specify constants such as constant sets of strings AasCore.Aas3_0_RC02.Verification Verify that the model fulfills the constraints AasCore.Aas3_0_RC02.Jsonization De/serialize from/to JSON AasCore.Aas3_0_RC02.Xmlization De/serialize from/to XML Please refer to Getting Started for a brief introduction on how to use the API."
  },
  "contributing.html": {
    "href": "contributing.html",
    "title": "Contributing",
    "keywords": "Contributing Issues Please report bugs or feature requests by creating GitHub issues . In Code If you want to contribute in code, pull requests are welcome! The biggest part of the code has been automatically generated by aas-core-codegen . It probably makes most sense to change the generator rather than add new functionality. However, this needs to be decided on a case-by-case basis. Please do create a new issue before you dive into coding. It can well be that we already started working on the feature, or that there are upstream or downstream complexities involved which you might not be aware of. Pull Requests Feature branches . We develop using the feature branches, see this section of the Git book . If you are a member of the development team, create a feature branch directly within the repository. Otherwise, if you are a non-member contributor, fork the repository and create the feature branch in your forked repository. See [this GitHub tuturial] for more guidance. Branch Prefix . Please prefix the branch with your Github user name ( e.g., mristin/Add-some-feature ). Continuous Integration . GitHub will run the continuous integration (CI) automatically through GitHub actions. The CI includes building the solution, running the test, inspecting the code etc. You can run the CI checks locally by calling: powershell src/Check.ps1 Commit Messages The commit messages follow the guidelines from https://chris.beams.io/posts/git-commit : Separate subject from body with a blank line, Limit the subject line to 50 characters, Capitalize the subject line, Do not end the subject line with a period, Use the imperative mood in the subject line, Wrap the body at 72 characters, and Use the body to explain what and why (instead of how )."
  },
  "getting_started/create.html": {
    "href": "getting_started/create.html",
    "title": "Create and Modify an AAS Model",
    "keywords": "Create and Modify an AAS Model The namespace AasCore.Aas3_0_RC02 contains all the classes of the meta-model. You can simply use their constructors to create an AAS model. Usually you start bottom-up, all the way up to the AasCore.Aas3_0_RC02.Environment . Example: Create an environment with a submodel Here is a very rudimentary example where we show how to create an environment which contains a submodel. The submodel will contain two elements, a property and a blob. (We will alias the namespace AasCore.Aas3_0_RC02 to Aas for readability. You might or might not want to write your code like that; the aliasing is not necessary.) using System.Collections.Generic; using Aas = AasCore.Aas3_0_RC02; public class Program { public static void Main() { // Create the first element var someElement = new Aas.Property( Aas.DataTypeDefXsd.Int) { Value=\"1984\" }; // Create the second element var content = new byte[4] { 0xDE, 0xAD, 0xBE, 0xEF }; var anotherElement = new Aas.Blob( \"application/octet-stream\") { Value=content }; // You can also directly access the element properties anotherElement.Value[3] = 0xED; // Nest the elements in a submodel var elements = new List<Aas.ISubmodelElement>() { someElement, anotherElement }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = elements }; // Now create the environment to wrap it all var submodels = new List<Aas.Submodel>() { submodel }; var environment = new Aas.Environment() { Submodels = submodels }; // You can access the properties from the children // as well. ( environment .Submodels[0] .SubmodelElements[1] as Aas.Blob ).Value[3] = 0xEF; // Now you can do something with the environment... } } (You can run the snippet at: https://dotnetfiddle.net/jaLVpH )"
  },
  "getting_started/install.html": {
    "href": "getting_started/install.html",
    "title": "Installation",
    "keywords": "Installation The SDK is available as a NuGet package AasCore.Aas3_0_RC02 . Change to your project's directory ( i.e , the directory where your .csproj file resides). Add the SDK as the dependency using dotnet : dotnet add package AasCore.Aas3_0_RC02 The SDK should be now available. You might probably need to re-start your IDE and re-build the solution for changes to take effect."
  },
  "getting_started/intro.html": {
    "href": "getting_started/intro.html",
    "title": "Getting Started with aas-core 3.0RC02 C# SDK",
    "keywords": "Getting Started with aas-core 3.0RC02 C# SDK Here's a quick intro to get you started with the SDK. See how you can: Install the SDK , Programmatically create and modify an AAS model , Iterate over and transform a model , Verify a model , De/serialize a model from and to JSON , and De/serialize a model from and to XML ."
  },
  "getting_started/iterate_and_transform.html": {
    "href": "getting_started/iterate_and_transform.html",
    "title": "Iterate and Transform",
    "keywords": "Iterate and Transform The SDK provides various ways how you can loop through the elements of the model, and how these elements can be transformed. Each following section will look into one of the approaches. DescendOnce and Descend If you are writing a simple script, want to use LINQ and do not care about the performance, the SDK provides two methods in the most general interface IClass , DescendOnce and Descend , which you can use to loop through the instances. Both DescendOnce and Descend iterate over model children of an IClass . DescendOnce , as it names suggests, stops after all the children has been iterated over. Descend continues recursively to grand-children etc. Here is a short example how you can get all the properties from an environment whose ID-short starts with another : using System.Collections.Generic; using System.Linq; using Aas = AasCore.Aas3_0_RC02; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var anotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"anotherProperty\" }; var yetAnotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"yetAnotherProperty\" }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty, anotherProperty, yetAnotherProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.Submodel>() { submodel } }; // Iterate over all properties which have \"another\" // in the ID-short foreach ( var prop in environment .Descend() .OfType<Aas.Property>() .Where( prop => prop.IdShort.ToLower().Contains(\"another\") ) ) { System.Console.WriteLine(prop.IdShort); } // Outputs: // anotherProperty // yetAnotherProperty } } (You can also run the snippet at: https://dotnetfiddle.net/4Y8yAM ) Iteration with Descend and DescendOnce works well if the performance is irrelevant. However, if the performance matters, this is not a good approach. First, all the children model elements will be visited (even though you need only a small subset). Second, the call to LINQ's OfType<Aas.Submodel> needs to perform a type cast for every child. Let's see in the next section how we could use a more efficient, but also a more complex approach. Visitor Visitor pattern is a common design pattern in software engineering. We will not explain the details of the pattern here as you can read about in the ample literature in books or in Internet. The cornerstone of the visitor pattern in double dispatch : instead of casting to the desired type during the iteration, we add a method Accept to IClass , whose implementations then directly dispatch to the appropriate method. This allows us to spare casts and directly dispatch the execution. The SDK already implements Accept methods, so you only have to implement the visitor. The visitor class has a visiting method for each class of the meta-model. In the SDK, we provide different flavors of the visitor abstract classes which you can readily implement: AbstractVisitor which needs all the visit methods to be implemented, VisitorThrough which visits all the elements and does nothing, and AbstractVisitorWithContext which propagates a context object along the iteration. Let us re-write the above example related to Descend method with a visitor pattern: using System.Collections.Generic; using Aas = AasCore.Aas3_0_RC02; using AasVisitation = AasCore.Aas3_0_RC02.Visitation; class Visitor : AasVisitation.VisitorThrough { public override void Visit(Aas.Property prop) { if (prop.IdShort.ToLower().Contains(\"another\")) { System.Console.WriteLine(prop.IdShort); } } }; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var anotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"anotherProperty\" }; var yetAnotherProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"yetAnotherProperty\" }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty, anotherProperty, yetAnotherProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.Submodel>() { submodel } }; // Iterate over all properties which have \"another\" // in the ID-short var visitor = new Visitor(); visitor.Visit(environment); // Outputs: // anotherProperty // yetAnotherProperty } } (You can run the snippet at: https://dotnetfiddle.net/mbswWD ) There are important differences to iteration with Descend : Due to double dispatch , we spare a cast. This is usually more efficient. We can handle multiple types of the elements, not only a single type ( Property in this case). This can allow for better readability of the code as well as better performance if two or more element types need to be considered in one iteration. The iteration logic in Descend lives very close to where it is executed. In contrast, the visitor needs to be defined as a separate class. While sometimes faster, writing the visitor makes the code less readable. Descend or Visitor? In general, people familiar with the visitor pattern and object-oriented programming will prefer, obviously, visitor class. People who like LINQ will prefer Descend . It is difficult to discuss different tastes, so you should probably come up with explicit code guidelines in your code and stick to them. Make sure you always profile before you sacrifice readability and blindly apply one or the other approach for performance reasons. Transformer A transformer pattern is an analogous to visitor pattern , where we \"transform\" the visited element into some other form (be it a string or a different object). It is very common in compiler design, where the abstract syntax tree is transformed into a different representation. The SDK provides two different flavors of a transformer: AbstractTransformer , where the model element is directly transformed into something, and AbstractTransformerWithContext , which propagates the context object along the transformations. Since we need to provide a transformation method for each class of the meta-model, we deliberately omit an example due to the length of the code. If you need a practical example, see the source code of the Verification static class, where we implemented the verification logic using an AbstractTransformer ."
  },
  "getting_started/jsonize.html": {
    "href": "getting_started/jsonize.html",
    "title": "JSON De/serialization",
    "keywords": "JSON De/serialization Our SDK handles the de/serialization of the AAS models from and to JSON format through the static class Jsonization . Serialize To serialize, you call the method ToJsonObject of Jsonization.Serialize static class on an instance of Environment which will convert it to an instance of System.Text.Json.Nodes.JsonObject . Here is a snippet that converts the environment first into an System.Text.Json.Nodes.JsonObject , and next converts the JSON object to text: using System.Collections.Generic; using Aas = AasCore.Aas3_0_RC02; using AasJsonization = AasCore.Aas3_0_RC02.Jsonization; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.Submodel>() { submodel } }; // Serialize to a JSON object var jsonObject = AasJsonization.Serialize.ToJsonObject( environment ); // Print the JSON object System.Console.WriteLine(jsonObject); // Outputs: // { // \"submodels\": [ // { // \"id\": \"some-unique-global-identifier\", // \"submodelElements\": [ // { // \"idShort\": \"someProperty\", // \"valueType\": \"xs:boolean\", // \"modelType\": \"Property\" // } // ], // \"modelType\": \"Submodel\" // } // ] // } } } (You can run the snippet at: https://dotnetfiddle.net/dkBbFS ) De-serialize Our SDK can convert a System.Text.Json.Nodes.JsonNode back to an instance of Environment . All you have to do is call the method EnvironmentFrom from the static class Jsonization.Deserialize . Here is an example snippet: using Nodes = System.Text.Json.Nodes; using Aas = AasCore.Aas3_0_RC02; using AasJsonization = AasCore.Aas3_0_RC02.Jsonization; public class Program { public static void Main() { var text = @\"{ \"\"submodels\"\": [ { \"\"id\"\": \"\"some-unique-global-identifier\"\", \"\"submodelElements\"\": [ { \"\"idShort\"\": \"\"someProperty\"\", \"\"valueType\"\": \"\"xs:boolean\"\", \"\"modelType\"\": \"\"Property\"\" } ], \"\"modelType\"\": \"\"Submodel\"\" } ] }\"; var jsonNode = Nodes.JsonNode.Parse( text); // De-serialize from the JSON node Aas.Environment environment = ( AasJsonization.Deserialize.EnvironmentFrom( jsonNode) ); // Print the types of the model elements contained // in the environment foreach (var something in environment.Descend()) { System.Console.WriteLine(something.GetType()); } // Outputs: // AasCore.Aas3_0_RC02.Submodel // AasCore.Aas3_0_RC02.Property } } (You can run the snippet at: https://dotnetfiddle.net/uCv2f3 ) Errors If there are any errors during the de-serialization, a Jsonization.Exception will be thrown. Errors occur whenever we encounter invalid JSON values. For example, the de-serialization method expects a JSON object, but encounters a JSON array instead."
  },
  "getting_started/verify.html": {
    "href": "getting_started/verify.html",
    "title": "Verify",
    "keywords": "Verify Our SDK allows you to verify that a model satisfies the constraints of the meta-model. The verification logic is concentrated in the static class Verification , and all it takes is a call to Verify method. The method Verify will check that constraints in the given model element are satisfied, including the recursion into children elements. The method returns an iterator of errors, which you can use to for further processing ( e.g. , report to the user). Here is a short example snippet: using System.Collections.Generic; using System.Linq; using Aas = AasCore.Aas3_0_RC02; using AasVerification = AasCore.Aas3_0_RC02.Verification; using AasReporting = AasCore.Aas3_0_RC02.Reporting; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { // 🗲🗲💀🗲🗲 // The ID-shorts must be proper variable names, // but there is a dash (\"-\") in this ID-short. IdShort = \"some-Property\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.Submodel>() { submodel } }; // Verify the environment and print out the errors foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine( error.Cause ); } // Outputs: // Invariant violated: // ID-short of Referables shall only feature letters, digits, underscore (``_``); // starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``. } } (You can run the snippet at: https://dotnetfiddle.net/aI03At ) Reporting The error is an instance of Error , living in the scope of the static class Reporting . You can use the methods GenerateJsonPath and GenerateRelativeXPath to convert the error's path to a readable path. Here is the above snippet modified so that the path is included in the prints: // ... using AasVerification = AasCore.Aas3_0_RC02.Verification; using AasReporting = AasCore.Aas3_0_RC02.Reporting; public class Program { public static void Main() { // ... // Verify the environment and print out the errors foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine( AasReporting.GenerateJsonPath(error.PathSegments) + \": \" + error.Cause ); } // Outputs: // submodels[0].submodelElements[0].idShort: Invariant violated: // ID-short of Referables shall only feature letters, digits, underscore (``_``); // starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``. } } (You can run the snippet at: https://dotnetfiddle.net/aI03At ) Limit the Number of Reported Errors Since the Verify method of the static class Verification gives you an iterator (an IEnumerable ), you can simply stop the verification after observing a certain number of errors. Here is a snippet which reports only the first 10 errors: // Verify the environment and print out the first 10 errors int errorCount = 0; foreach (var error in AasVerification.Verify(environment)) { System.Console.WriteLine(error.Cause); errorCount++; if (errorCount == 10) break; } Omitted Constraints Not all constraints specified in the meta-model can be verified. Some constraints require external dependencies such as an AAS registry. Verifying the constraints with external dependencies is out-of-scope of our SDK, as we still lack standardized interfaces to those dependencies. However, all the constraints which need no external dependency are verified. For a full list of exception, consult the aas-core-meta description of the meta-model which this SDK has been generated after."
  },
  "getting_started/xmlize.html": {
    "href": "getting_started/xmlize.html",
    "title": "XML De/serialization",
    "keywords": "XML De/serialization The code that de/serializes AAS models from and to XML documents lives in the static class Xmlization . Serialize You serialize a model using the static class Xmlization.Serialize by calling its To method on an Environment . The To method writes to a System.Xml.XmlWriter . Here is an example snippet: using System.Collections.Generic; using Aas = AasCore.Aas3_0_RC02; using AasXmlization = AasCore.Aas3_0_RC02.Xmlization; public class Program { public static void Main() { // Prepare the environment var someProperty = new Aas.Property( Aas.DataTypeDefXsd.Boolean) { IdShort = \"someProperty\", }; var submodel = new Aas.Submodel( \"some-unique-global-identifier\") { SubmodelElements = new List<Aas.ISubmodelElement>() { someProperty } }; var environment = new Aas.Environment() { Submodels = new List<Aas.Submodel>() { submodel } }; // Serialize to an XML writer var outputBuilder = new System.Text.StringBuilder(); using var writer = System.Xml.XmlWriter.Create( outputBuilder, new System.Xml.XmlWriterSettings() { Encoding = System.Text.Encoding.UTF8, OmitXmlDeclaration = true } ); AasXmlization.Serialize.To( environment, writer ); // Print the output System.Console.WriteLine( outputBuilder.ToString() ); // Outputs (all on a single line): // <environment xmlns=\"http://www.admin-shell.io/aas/3/0/RC02\"> // <submodels><submodel><id>some-unique-global-identifier</id> // <submodelElements><property><idShort>someProperty</idShort> // <valueType>xs:boolean</valueType></property></submodelElements> // </submodel></submodels></environment> } } (You can run the snippet at: https://dotnetfiddle.net/VEL2jU ) De-serialize The de-serialization is encapsulated in Xmlization.Deserialize static class. The crucial method is EnvironmentFrom which reads from an System.Xml.XmlReader and re-creates back an instance of Environment . Here is a snippet which parses XML as text and then de-serializes it into an instance of Environment : using System.Collections.Generic; using Aas = AasCore.Aas3_0_RC02; using AasXmlization = AasCore.Aas3_0_RC02.Xmlization; public class Program { public static void Main() { var text = ( \"<environment xmlns=\\\"http://www.admin-shell.io/aas/3/0/RC02\\\">\" + \"<submodels><submodel><id>some-unique-global-identifier</id>\" + \"<submodelElements><property><idShort>someProperty</idShort>\" + \"<valueType>xs:boolean</valueType></property></submodelElements>\" + \"</submodel></submodels></environment>\" ); using var stringReader = new System.IO.StringReader( text); using var xmlReader = System.Xml.XmlReader.Create( stringReader); var environment = AasXmlization.Deserialize.EnvironmentFrom( xmlReader); // Print the types of the model elements contained // in the environment foreach (var something in environment.Descend()) { System.Console.WriteLine(something.GetType()); } // Outputs: // AasCore.Aas3_0_RC02.Submodel // AasCore.Aas3_0_RC02.Property } } (You can run the snippet at: https://dotnetfiddle.net/TD0Ro8 ) Errors If the XML document from System.Xml.XmlReader comes in an unexpected form, our SDK throws a Xmlization.Exception . This can happen, for example, if unexpected XML elements or XML attributes are encountered, or an expected XML element is missing."
  },
  "index.html": {
    "href": "index.html",
    "title": "aas-core 3.0RC02 C#",
    "keywords": "aas-core 3.0RC02 C# This is a software development kit (SDK) to: manipulate, verify, and de/serialize to and from JSON and XML ... Asset Administration Shells based on the version 3.0VRC02 of the meta-model . For a brief introduction, see Getting Started . For a detailed documentation of the API, see API ."
  }
}